<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: plugins/rendering/Box.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: plugins/rendering/Box.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
(function (plugin, core, scene) {

    var DEFAULTS = {
            //next values are code blocked values
            minPointSize : 0.2,
            medPointSize : 1.0,
            majPointSize : 1.5,
            minSize : 10.0,
            pntTexture: THREE.ImageUtils.loadTexture("js/mlj/plugins/rendering/textures/sprites/disc.png"),
            epsilonPercentage : 3.0/100.0,
            spriteOffset : 2.75,
            //next are GUI settable values
            minorFactor : 0.2,
            majorFactor : 0.5,
            pntSize : 0.10,
            pntColor : new THREE.Color('#FF0000')
        };

    var plug = new plugin.Rendering({
        name: "Box",
        tooltip: "Box Tooltip",
        icon: "img/icons/box.png",
        toggle: true,
        on: false,
        updateOnLayerAdded: true,
        loadShader: ["BoxFragment.glsl", "BoxVertex.glsl"]
    },DEFAULTS);

    var boxEnablerQuotes, boxMinorFactorWidget, boxMajorFactorWidget, boxPntSizeWidget, boxPntColorWidgets, boxFontFaceChoiceWidget, boxFontSizeChoiceWidget, boxFontBorderThickChoiceWidget;
    plug._init = function (guiBuilder) {

        boxEnablerQuotes = guiBuilder.Choice({
            label: "Quotes",
            tooltip: "Enable/disable quotes",
            options: [
                {content: "enable", value: true},
                {content: "disable", value: false, selected: true}
            ],
            bindTo: function(enabled){
                boxEnablerQuotes._changeValue(enabled);
                $(document).trigger("SceneLayerUpdated", [scene.getSelectedLayer()]);
            }
        });

        boxMinorFactorWidget = guiBuilder.RangedFloat({
            label: "Minor Factor",
            tooltip: "Distance between two consecutive misurations in non quoted axis",
            min: 0.1, step: 0.1, max:100,
            defval: DEFAULTS.minorFactor,
            bindTo: function(newFactor){
                boxMinorFactorWidget.setValue(newFactor);
                $(document).trigger("SceneLayerUpdated", [scene.getSelectedLayer()]);
            }
        });
        boxMajorFactorWidget = guiBuilder.RangedFloat({
            label: "Major Factor",
            tooltip: "Distance between two consecutive misurations in quoted axis",
            min: 0.5, step: 0.1, max:250,
            defval: DEFAULTS.majorFactor,
            bindTo: function(newFactor){
                boxMajorFactorWidget.setValue(newFactor);
                $(document).trigger("SceneLayerUpdated", [scene.getSelectedLayer()]);
            }
        });
        boxPntSizeWidget = guiBuilder.RangedFloat({
            label: "Point Size",
            tooltip: "Size of a point in the 3 axis",
            min: 0.05, step: 0.05, max:100,
            defval: DEFAULTS.pntSize,
            bindTo: "pntSize"
        });
        boxPntColorWidget = guiBuilder.Color({
            label: "Thicks color",
            tooltip: "Color of the material related to a point in non quoted axis",
            color: "#"+DEFAULTS.pntColor.getHexString(),
            bindTo: "pntColor"
        });

        boxFontFaceChoiceWidget = guiBuilder.Choice({
            label: "Font Face",
            tooltip: "Choose the labels font face",
            options: [
                {content: "Arial", value: "0", selected: true},
                {content: "Georgia", value: "1"},
                {content: "Droid Sans", value: "2"},
                {content: "Droid Serif", value: "3"}
            ],
            bindTo: function(newFontface){
                $(document).trigger("SceneLayerUpdated", [scene.getSelectedLayer()]);
            }
        });

        boxFontSizeChoiceWidget = guiBuilder.Integer({
            min: 5, step: 1, defval: 10,
            label: "Font Size",
            tooltip: "Choose the labels font size",
            bindTo: function(newFontsize){
                $(document).trigger("SceneLayerUpdated", [scene.getSelectedLayer()]);
            }
        });

        boxFontBorderThickChoiceWidget = guiBuilder.Integer({
            min: 0, step: 1, defval: 4,
            label: "Font Border Thickness",
            tooltip: "Choose the labels font border thickness",
            bindTo: function(newFontsize){
                $(document).trigger("SceneLayerUpdated", [scene.getSelectedLayer()]);
            }
        });
    };

    plug._applyTo = function (meshFile, on) {

        if (on === false) {
            scene.removeOverlayLayer(meshFile, plug.getName());
            return;
        }

        var params = meshFile.overlaysParams.getByKey(plug.getName());

        var attributes = {
            pntMinSize: {type: 'f', value: []},
            pntType: {type: "f", value: []}
        };

        var uniforms = {
            pntEnable: {},
            pntColor: {type: "c", value: params.pntColor},
            pntSize: {type: "f", value: params.pntSize},
            pntTexture: {type: "t", value: DEFAULTS.pntTexture}
        };

        var shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                attributes: attributes,
                vertexShader: this.shaders.getByKey("BoxVertex.glsl"),
                fragmentShader: this.shaders.getByKey("BoxFragment.glsl"),
                alphaTest: 0.9
            });

        //var needed to group all (pseudo) "subclasses" of THREE.Mesh
        var meshesGroup = new THREE.Mesh( undefined, shaderMaterial);

        //label parameters
        var lblParameters = {
            fontFace : boxFontFaceChoiceWidget.getContent(),
            fontSize : boxFontSizeChoiceWidget.getValue(),
            borderThickness : boxFontBorderThickChoiceWidget.getValue(),
            borderColor : {r:0, g:0, b:0, a:0},
            bgColor : {r:255, g:255, b:255, a:0}
        };

        /* Overlay bounding box (a THREE.BoxHelper overlay) */

        var bbHelper = new THREE.BoundingBoxHelper(meshFile.getThreeMesh(), 0xffffff);
        bbHelper.update();
        var bbox = new THREE.BoxHelper(bbHelper);
        bbox.update(meshFile.getThreeMesh());
        meshesGroup.add(bbox);

        /* Overlays related to quotes (3 THREE.PointCloud overlay) and overlay labels (2 groups of
           THREE.Sprite overlays) */

        if(boxEnablerQuotes.getValue()){
            //calculate bbox
            var geometry = meshFile.getThreeMesh().geometry.clone();
            if ( geometry.boundingBox === null ) geometry.computeBoundingBox();
            var bboxMax = geometry.boundingBox.max;
            var bboxMin = geometry.boundingBox.min;

            /*                      0: bboxmax.x, bboxmax.y, bboxmax.z
                                    1: bboxmin.x, bboxmax.y, bboxmax.z
                          5____4    2: bboxmin.x, bboxmin.y, bboxmax.z
                        1/___0/|    3: bboxmax.x, bboxmin.y, bboxmax.z
             LEGENDA:   | 6__|_7    4: bboxmax.x, bboxmax.y, bboxmin.z
                        2/___3/     5: bboxmin.x, bboxmax.y, bboxmin.z
                                    6: bboxmin.x, bboxmin.y, bboxmin.z
                                    7: bboxmax.x, bboxmin.y, bboxmin.z */

            //var needed to group labels
            var labelsGroup = new THREE.Mesh();

            //adding internal quotes and labels
            var geometry = generatePointCloudGeometry(bboxMax, bboxMin, boxMinorFactorWidget.getValue(), boxMajorFactorWidget.getValue(), lblParameters, labelsGroup);
            var pcBuffer = new THREE.PointCloud( geometry, shaderMaterial);

            meshesGroup.add(pcBuffer);
            meshesGroup.add(labelsGroup);
        }

        scene.addOverlayLayer(meshFile, plug.getName(), meshesGroup);
    };

    /**
     * Method to generate the point cloud geometry in-segment
     * @param {Vector3} max The max of the bbox
     * @param {Vector3} min The min of the bbox
     * @param {Object} lengths The lengths of the 3 singol edges will be quoted
     * @param {Number} pointfactor The edge subdivisions number
     * @param {Color} pointcolor The color of a generic point
     * @param {Object} lblParameters The parameters needed for a label
     * @param {THREE.Group} labelsgroup The group witch usage is to add labels in
     * @memberOf MLJ.plugins.rendering.Box
     * @author Stefano Giammori
    */
    function generatePointCloudGeometry(max, min, minorFactor, majorFactor, lblParameters, labelsgroup){
        var geometry, div, x, y, z, j, k, xCenter=0, yCenter=0, zCenter=0;

        geometry = new THREE.BufferGeometry();
        var positions = new Array();
        var pntTypes = new Array();
        var pntMinSizes = new Array();

        //segment 0 - 3
        var id = 0;
        var i = 0;
        k = 0;
        //MeshSizes dependent value ?
        x = max.x + 0.1;
        y = max.y;
        z = max.z;

        var epsilon = (max.y - min.y) * DEFAULTS.epsilonPercentage;
        //minorFactor = smartFactor(min.y, max.y, minorFactor);
        //majorFactor = smartFactor(min.y, max.y, majorFactor);

        var y,y0 = max.y, y1 = max.y,ysupp = undefined;

        while(y0>=min.y || y1>=min.y){

            //first minor quotes
            if(y0>=min.y){
                y = y0;
                y0 -=minorFactor;

                pntMinSizes[i] = DEFAULTS.minSize;
                pntTypes[i++] = DEFAULTS.minPointSize;

                positions[(3 * k) + id] = x;
                positions[(3 * k + 1) + id] = y;
                positions[(3 * k + 2) + id] = z;

                k++;
            }

            //then major quotes
            if(y1 >= min.y){
                y = y1;
                y1 = (ysupp==undefined? y1 - majorFactor : (ysupp==y1?y1-majorFactor:ysupp) );
                ysupp = undefined;

                var maxdistance = ( y-max.y>=0 ? y-max.y : (y-max.y)*-1 ) / 2;
                var middistance = ( y>=0 ? y : -y ) / 2;
                var mindistance = ( y-min.y>=0 ? y-min.y : (y-min.y)*-1 ) / 2;

                if( maxdistance&lt;epsilon || middistance&lt;epsilon || mindistance&lt;epsilon ){

                    if(maxdistance&lt;epsilon) y = max.y;
                    else if(middistance&lt;epsilon) y = 0;
                    else y = min.y;

                    pntMinSizes[i] = DEFAULTS.minSize;
                    pntTypes[i++] = DEFAULTS.majPointSize;
                    var sprite = makeTextSprite(
                                                (y&lt;0?(y*-1).toFixed(2):y.toFixed(2)),
                                                { 'x' : x+epsilon*DEFAULTS.spriteOffset, 'y' : y, 'z': z },
                                                lblParameters
                                               );
                    labelsgroup.add( sprite );

                    positions[(3 * k) + id] = x;
                    positions[(3 * k + 1) + id] = y;
                    positions[(3 * k + 2) + id] = z;

                    k++;
                    if(ysupp==undefined){
                        if(y>0 &amp;&amp; y1&lt;0){
                            ysupp = y1;
                            y1 = 0;
                        }else if(y>min.y &amp;&amp; y1&lt;min.y){
                            ysupp = y1;
                            y1 = min.y;
                        }
                    }else
                        y1=ysupp;
                }else{
                    if(ysupp==undefined){
                        if(y>0 &amp;&amp; y1&lt;0){
                            ysupp = y1;
                            y1 = 0;
                        }else if(y>min.y &amp;&amp; y1&lt;min.y){
                            ysupp = y1;
                            y1 = min.y;
                        }

                        pntMinSizes[i] = DEFAULTS.minSize;
                        pntTypes[i++] = DEFAULTS.medPointSize;

                        var sprite = makeTextSprite(
                                                    (y&lt;0?(y*-1).toFixed(2):y.toFixed(2)),
                                                    { 'x' : x+epsilon*DEFAULTS.spriteOffset, 'y' : y, 'z': z },
                                                    lblParameters
                                                   );
                        labelsgroup.add( sprite );

                        positions[(3 * k) + id] = x;
                        positions[(3 * k + 1) + id] = y;
                        positions[(3 * k + 2) + id] = z;

                        k++;
                    }else
                        y1=ysupp;
                }
            }
        }

        //segment 2 - 3
        id = k * 3;
        k = 0;
        x = max.x;
        y = min.y-0.1;
        z = max.z;

        //minorFactor = smartFactor(min.x, max.x, minorFactor);
        //majorFactor = smartFactor(min.x, max.x, majorFactor);

        var x,x0 = max.x, x1 = max.x,xsupp = undefined;

        while(x0>=min.x || x1>=min.x){

            //first minor quotes
            if(x0>=min.x){
                x = x0;
                x0 -=minorFactor;

                pntMinSizes[i] = DEFAULTS.minSize;
                pntTypes[i++] = DEFAULTS.minPointSize;

                positions[(3 * k) + id] = x;
                positions[(3 * k + 1) + id] = y;
                positions[(3 * k + 2) + id] = z;

                k++;
            }

            //then major quotes
            if(x1 >= min.x){
                x = x1;
                x1 = (xsupp==undefined? x1 - majorFactor : (xsupp==x1?x1-majorFactor:xsupp) );
                xsupp = undefined;

                var maxdistance = ( x-max.x>=0 ? x-max.x : (x-max.x)*-1 ) / 2;
                var middistance = ( x>=0 ? x : -x ) / 2;
                var mindistance = ( x-min.x>=0 ? x-min.x : (x-min.x)*-1 ) / 2;

                if( maxdistance&lt;epsilon || middistance&lt;epsilon || mindistance&lt;epsilon ){

                    if(maxdistance&lt;epsilon) x = max.x;
                    else if(middistance&lt;epsilon) x = 0;
                    else x = min.x;

                    pntMinSizes[i] = DEFAULTS.minSize;
                    pntTypes[i++] = DEFAULTS.majPointSize;
                    var sprite = makeTextSprite(
                                                (x&lt;0?(x*-1).toFixed(2):x.toFixed(2)),
                                                { 'x' : x, 'y' : y-epsilon*DEFAULTS.spriteOffset, 'z': z },
                                                lblParameters
                                               );
                    labelsgroup.add( sprite );

                    positions[(3 * k) + id] = x;
                    positions[(3 * k + 1) + id] = y;
                    positions[(3 * k + 2) + id] = z;

                    k++;

                    if(xsupp==undefined){
                        if(x>0 &amp;&amp; x1&lt;0){
                            xsupp = x1;
                            x1 = 0;
                        }else if(x>min.x &amp;&amp; x1&lt;min.x){
                            xsupp = x1;
                            x1 = min.x;
                        }
                    }else
                        x1=xsupp;
                }else{
                    if(xsupp==undefined){
                        if(x>0 &amp;&amp; x1&lt;0){
                            xsupp = x1;
                            x1 = 0;
                        }else if(x>min.x &amp;&amp; x1&lt;min.x){
                            xsupp = x1;
                            x1 = min.x;
                        }

                        pntMinSizes[i] = DEFAULTS.minSize;
                        pntTypes[i++] = DEFAULTS.medPointSize;

                        var sprite = makeTextSprite(
                                                    (x&lt;0?(x*-1).toFixed(2):x.toFixed(2)),
                                                    { 'x' : x, 'y' : y-epsilon*DEFAULTS.spriteOffset, 'z': z },
                                                    lblParameters
                                                   );
                        labelsgroup.add( sprite );

                        positions[(3 * k) + id] = x;
                        positions[(3 * k + 1) + id] = y;
                        positions[(3 * k + 2) + id] = z;

                        k++;
                    }else
                        x1=xsupp;
                }
            }
        }

        //segment 0 - 4
        id += k * 3;
        k = 0;
        x = max.x;
        y = max.y+0.1;
        z = max.z;

        //minorFactor = smartFactor(min.z, max.z, minorFactor);
        //majorFactor = smartFactor(min.z, max.z, majorFactor);

        var z,z0 = max.z, z1 = max.z,zsupp = undefined;

        while(z0>=min.z || z1>=min.z){

            //first minor quotes
            if(z0>=min.z){
                z = z0;
                z0 -=minorFactor;

                pntMinSizes[i] = DEFAULTS.minSize;
                pntTypes[i++] = DEFAULTS.minPointSize;

                positions[(3 * k) + id] = x;
                positions[(3 * k + 1) + id] = y;
                positions[(3 * k + 2) + id] = z;

                k++;
            }

            //then major quotes
            if(z1 >= min.z){
                z = z1;
                z1 = (zsupp==undefined? z1 - majorFactor : (zsupp==z1?z1-majorFactor:zsupp) );
                zsupp = undefined;

                var maxdistance = ( z-max.z>=0 ? z-max.z : (z-max.z)*-1 ) / 2;
                var middistance = ( z>=0 ? z : -z ) / 2;
                var mindistance = ( z-min.z>=0 ? z-min.z : (z-min.z)*-1 ) / 2;

                if( maxdistance&lt;epsilon || middistance&lt;epsilon || mindistance&lt;epsilon ){

                    if(maxdistance&lt;epsilon) z = max.z;
                    else if(middistance&lt;epsilon) z = 0;
                    else z = min.z;

                    pntMinSizes[i] = DEFAULTS.minSize;
                    pntTypes[i++] = DEFAULTS.majPointSize;
                    var sprite = makeTextSprite(
                                                (z&lt;0?(z*-1).toFixed(2):z.toFixed(2)),
                                                { 'x' : x, 'y' : y+epsilon*DEFAULTS.spriteOffset, 'z': z },
                                                lblParameters
                                               );
                    labelsgroup.add( sprite );

                    positions[(3 * k) + id] = x;
                    positions[(3 * k + 1) + id] = y;
                    positions[(3 * k + 2) + id] = z;

                    k++;

                    if(zsupp==undefined){
                        if(z>0 &amp;&amp; z1&lt;0){
                            zsupp = z1;
                            z1 = 0;
                        }else if(z>min.z &amp;&amp; z1&lt;min.z){
                            zsupp = z1;
                            z1 = min.z;
                        }
                    }else
                        z1=zsupp;
                }else{
                    if(zsupp==undefined){
                        if(z>0 &amp;&amp; z1&lt;0){
                            zsupp = z1;
                            z1 = 0;
                        }else if(z>min.z &amp;&amp; z1&lt;min.z){
                            zsupp = z1;
                            z1 = min.z;
                        }

                        pntMinSizes[i] = DEFAULTS.minSize;
                        pntTypes[i++] = DEFAULTS.medPointSize;

                        var sprite = makeTextSprite(
                                                    (z&lt;0?(z*-1).toFixed(2):z.toFixed(2)),
                                                    { 'x' : x, 'y' : y+epsilon*DEFAULTS.spriteOffset, 'z': z },
                                                    lblParameters
                                                   );
                        labelsgroup.add( sprite );

                        positions[(3 * k) + id] = x;
                        positions[(3 * k + 1) + id] = y;
                        positions[(3 * k + 2) + id] = z;

                        k++;
                    }else
                        z1=zsupp;
                }
            }
        }

        positions = arrayToF32Array(positions.length, positions);
        pntMinSizes = arrayToF32Array(pntMinSizes.length, pntMinSizes);
        pntTypes = arrayToF32Array(pntTypes.length, pntTypes);

        geometry.addAttribute('position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute('pntMinSize', new THREE.BufferAttribute( pntMinSizes, 1 ) );
        geometry.addAttribute('pntType', new THREE.BufferAttribute( pntTypes, 1 ) );

        return geometry;
    }

    function smartFactor(a,b,factor) {
        var minorQuotes = (b - a) / factor;
        var badInterval = (b - a) / minorQuotes;
        var smartRoundedInterval = Math.pow(10, Math.floor(Math.log(badInterval) / Math.LN10));
        var v1 = factor - smartRoundedInterval;
        var v2 = factor - smartRoundedInterval * 2;
        var v3 = factor - smartRoundedInterval / 2;
        var minval = Math.min(v1, v2, v3);
        switch (minval) {
            case v1:
                factor = smartRoundedInterval;
                break;
            case v2:
                factor = smartRoundedInterval * 2;
                break;
            case v3:
                factor = smartRoundedInterval / 2;
                break;
            default:
                factor;
        }
        return factor;
    }

    /**
      * Make and return a Float32Array from an Array of len indexes
      * @param {Number} len length of the array
      * @param {Object} array array to transform
      * @memberOf MLJ.plugins.rendering.Box
      * @author Stefano Giammori
    */
    function arrayToF32Array(len, array){
        var f32array = new Float32Array(len);
        for (i = 0; i &lt; len; i++) {
            f32array[i] = array[i];
        }
        return f32array;
    }

    /**
      * Make a text texture &lt;code>message&lt;/code> with HTML approach
      * @param {String} message Message to be applied to texture
      * @param {Vector3} position The position of the texture sprite
      * @param {Object} parameters The sprite's parameters
      * @memberOf MLJ.plugins.rendering.Box
      * @author Stefano Giammori
    */
    function makeTextSprite( message, position, parameters )
    {
    	if ( parameters === undefined ) parameters = {};

    	//extract label params
    	var fontface = parameters.hasOwnProperty("fontFace") ?
    	    parameters["fontFace"] : "Arial";
    	var fontsize = parameters.hasOwnProperty("fontSize") ?
    		parameters["fontSize"] : 10;
    	var borderThickness = parameters.hasOwnProperty("borderThickness") ?
    		parameters["borderThickness"] : 4;
    	var borderColor = parameters.hasOwnProperty("borderColor") ?
    		parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 }; //black, visible
    	var backgroundColor = parameters.hasOwnProperty("bgColor") ?
    		parameters["bgColor"] : {r:255, g:255, b:255, a:1.0} //white, visible

        //prepare label
    	var canvas = document.createElement('canvas');
    	var context = canvas.getContext('2d');
    	context.font = "normal " + fontsize + "px " + fontface;

    	// get size data (height depends only on font size)
    	var textWidth = context.measureText(message).width;

    	canvas.width = textWidth + borderThickness * 2;
        canvas.height = fontsize + borderThickness * 2;

        //set the param font into context
        context.font = "normal " + fontsize + "px " + fontface;
    	//set context background color
    	context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
    								  + backgroundColor.b + "," + backgroundColor.a + ")";
    	//set context border color
    	context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
    								  + borderColor.b + "," + borderColor.a + ")";
    	//set border thickness
    	context.lineWidth = borderThickness;
    	/** //MEMO : (add +x) ~~ go right; (add +y) ~~ go down) ]
    	   Set the rectangular frame (ctx, top-left, top, width, height, radius of the 4 corners)
    	*/
    	roundRect(context,
    	          borderThickness/2,
    	          borderThickness/2,
    	          textWidth + borderThickness,
    	          fontsize + borderThickness,
    	          6);
    	context.fillStyle = "rgba(0, 0, 0, 1.0)";
    	/** Set starting point of text, in which pt(borderThickness, fontsize+borderThickness/2) represent the
    	top left of the top-left corner of the texture text in the canvas. */
    	context.fillText( message, borderThickness, fontsize + borderThickness/2);
    	//canvas contents will be used for create a texture
    	var texture = new THREE.Texture(canvas)
    	texture.needsUpdate = true;
    	texture.minFilter = THREE.LinearFilter;
    	var spriteMaterial = new THREE.SpriteMaterial({ map: texture, useScreenCoordinates: false, color: 0xffffff, fog: true } );
    	var sprite = new THREE.Sprite( spriteMaterial );
    	sprite.scale.set( textWidth/100, fontsize/100, 1 );
    	sprite.position.set( position.x, position.y, position.z);
    	return sprite;
    }

    //function for drawing rounded rectangles
    function roundRect(ctx, x, y, w, h, r)
    {
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.lineTo(x+w-r, y);
        ctx.quadraticCurveTo(x+w, y, x+w, y+r);
        ctx.lineTo(x+w, y+h-r);
        ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
        ctx.lineTo(x+r, y+h);
        ctx.quadraticCurveTo(x, y+h, x, y+h-r);
        ctx.lineTo(x, y+r);
        ctx.quadraticCurveTo(x, y, x+r, y);
        ctx.closePath();
        ctx.fill();
    	ctx.stroke();
    }

    /**
     * Make a text texture &lt;code>message&lt;/code> with TextGeometry approach
     * @param {Vector3} max The max of the bbox
     * @param {Vector3} min The min of the bbox
     * @param {Number} pointfactor The edge subdivisions number
     * @memberOf MLJ.plugins.rendering.Box
     * @author Stefano Giammori
    */
    function generateLabels(max, min, pointfactor) {
        var textGeo = new THREE.TextGeometry(
            'C',
            {
                size: 20,
                height: 2,
                curveSegments: 4,
                font: 'helvetiker',
                weight: 'normal',
                style: 'normal',
                bevelThickness: 2,
                bevelSize : 1.5,
                bevelSegments : 3,
                bevelEnabled: true
            }
        );

        materialArray = [
            new THREE.MeshBasicMaterial( { color: 0xFFFFFF  } ),
            new THREE.MeshBasicMaterial( { color: 0x666666, shading: THREE.SmoothShading } )
        ]

        textMaterial = new THREE.MeshFaceMaterial(materialArray)
        textGeo = new THREE.Mesh(textGeo, textMaterial)

        //MeshSizes dependent value?
        textGeo.position.x = max.x + 0.1;
        textGeo.position.y = max.y;
        textGeo.position.z = max.z;

        return textGeo;
    }

    plugin.Manager.install(plug);

})(MLJ.core.plugin, MLJ.core, MLJ.core.Scene);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MLJ.core.AmbientLight.html">MLJ.core.AmbientLight</a></li><li><a href="MLJ.core.Headlight.html">MLJ.core.Headlight</a></li><li><a href="MLJ.core.MeshFile.html">MLJ.core.MeshFile</a></li><li><a href="MLJ.core.plugin.Filter.html">MLJ.core.plugin.Filter</a></li><li><a href="MLJ.core.plugin.GUIBuilder.html">MLJ.core.plugin.GUIBuilder</a></li><li><a href="MLJ.core.plugin.Plugin.html">MLJ.core.plugin.Plugin</a></li><li><a href="MLJ.Error.html">MLJ.Error</a></li><li><a href="MLJ.gui.component.Accordion.html">MLJ.gui.component.Accordion</a></li><li><a href="MLJ.gui.component.AccordionEntry.html">MLJ.gui.component.AccordionEntry</a></li><li><a href="MLJ.gui.component.Button.html">MLJ.gui.component.Button</a></li><li><a href="MLJ.gui.component.ButtonSet.html">MLJ.gui.component.ButtonSet</a></li><li><a href="MLJ.gui.component.CheckBox.html">MLJ.gui.component.CheckBox</a></li><li><a href="MLJ.gui.component.ColorPicker.html">MLJ.gui.component.ColorPicker</a></li><li><a href="MLJ.gui.component.ComboBox.html">MLJ.gui.component.ComboBox</a></li><li><a href="MLJ.gui.component.Component.html">MLJ.gui.component.Component</a></li><li><a href="MLJ.gui.component.CustomToggleButton.html">MLJ.gui.component.CustomToggleButton</a></li><li><a href="MLJ.gui.component.Dialog.html">MLJ.gui.component.Dialog</a></li><li><a href="MLJ.gui.component.FileButton.html">MLJ.gui.component.FileButton</a></li><li><a href="MLJ.gui.component.Label.html">MLJ.gui.component.Label</a></li><li><a href="MLJ.gui.Component.MLJ.gui.component.RangedFloat.html">MLJ.gui.Component.MLJ.gui.component.RangedFloat</a></li><li><a href="MLJ.gui.component.Pane.html">MLJ.gui.component.Pane</a></li><li><a href="MLJ.gui.component.PiP.html">MLJ.gui.component.PiP</a></li><li><a href="MLJ.gui.component.Spinner.html">MLJ.gui.component.Spinner</a></li><li><a href="MLJ.gui.component.TextField.html">MLJ.gui.component.TextField</a></li><li><a href="MLJ.gui.component.ToggleButton.html">MLJ.gui.component.ToggleButton</a></li><li><a href="MLJ.gui.component.ToolBar.html">MLJ.gui.component.ToolBar</a></li><li><a href="MLJ.gui.Param.html">MLJ.gui.Param</a></li><li><a href="MLJ.gui.Param.Color.html">MLJ.gui.Param.Color</a></li><li><a href="MLJ.gui.Param.RangedFloat.html">MLJ.gui.Param.RangedFloat</a></li><li><a href="MLJ.gui.Widget_.html">MLJ.gui.Widget</a></li><li><a href="MLJ.gui.widget._Info.html">MLJ.gui.widget._Info</a></li><li><a href="MLJ.gui.widget._LayersPane.html">MLJ.gui.widget._LayersPane</a></li><li><a href="MLJ.gui.widget._Log.html">MLJ.gui.widget._Log</a></li><li><a href="MLJ.gui.widget._Logo.html">MLJ.gui.widget._Logo</a></li><li><a href="MLJ.gui.widget._SceneBar.html">MLJ.gui.widget._SceneBar</a></li><li><a href="MLJ.gui.widget._SearchTool.html">MLJ.gui.widget._SearchTool</a></li><li><a href="MLJ.util.AssociativeArray.html">MLJ.util.AssociativeArray</a></li><li><a href="MLJ.util.AssociativeArray-_Iterator.html">MLJ.util.AssociativeArray~_Iterator</a></li></ul><h3>Events</h3><ul><li><a href="MLJ.core.File.html#event:MeshFileOpened">MLJ.core.File#event:MeshFileOpened</a></li><li><a href="MLJ.core.File.html#event:MeshFileReloaded">MLJ.core.File#event:MeshFileReloaded</a></li><li><a href="MLJ.core.Scene.html#event:SceneLayerAdded">MLJ.core.Scene#event:SceneLayerAdded</a></li><li><a href="MLJ.core.Scene.html#event:SceneLayerReloaded">MLJ.core.Scene#event:SceneLayerReloaded</a></li><li><a href="MLJ.core.Scene.html#event:SceneLayerSelected">MLJ.core.Scene#event:SceneLayerSelected</a></li><li><a href="MLJ.core.Scene.html#event:SceneLayerUpdated">MLJ.core.Scene#event:SceneLayerUpdated</a></li></ul><h3>Namespaces</h3><ul><li><a href="MLJ.html">MLJ</a></li><li><a href="MLJ.core.File.html">MLJ.core.File</a></li><li><a href="MLJ.core.plugin.html">MLJ.core.plugin</a></li><li><a href="MLJ.core.Scene.html">MLJ.core.Scene</a></li><li><a href="MLJ.gui.html">MLJ.gui</a></li><li><a href="MLJ.gui.component.html">MLJ.gui.component</a></li><li><a href="MLJ.gui.widget.html">MLJ.gui.widget</a></li><li><a href="MLJ.util.html">MLJ.util</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Module">Module</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.2</a> on Sat Aug 08 2015 08:39:32 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
